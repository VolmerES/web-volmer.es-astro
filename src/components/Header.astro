---
const pathname = Astro.url.pathname;
 
 const navLinks = [
     { href: '/', label: 'INICIO' },
     { href: '/42', label: '42 MADRID' },
     { href: '/aplicaciones', label: 'APLICACIONES' },
     { href: '/portfolio', label: 'PORTAFOLIO' },
     { href: '/servicios', label: 'SERVICIOS' },
     { href: '/blog', label: 'BLOG' },
 ];
 
 const appLink = "https://play.google.com/store/apps/details?id=es.volmer.gallery_swipe_ai&pcampaignid=web_share";
 ---
 
 <header 
     id="main-header"
     data-theme="dark"
     class:list={[
         "fixed top-6 left-1/2 -translate-x-1/2 z-50 transition-all duration-500 backdrop-blur-md border rounded-full shadow-2xl overflow-hidden",
         "w-[90%] md:w-auto max-w-5xl group hover:scale-[1.02]",
         "bg-[#121212]/90 border-white/10"
     ]}
 >
     <!-- Particles Canvas -->
     <canvas id="header-canvas" class="absolute inset-0 w-full h-full pointer-events-none opacity-40 z-0"></canvas>
 
     <div class="relative z-10 h-14 px-4 md:px-6 flex items-center justify-between gap-4 md:gap-8">
         <a href="/" class="text-xl font-bold font-heading tracking-tighter transition-colors shrink-0 hover:text-neon-cyan text-white">
             VOLMER<span class="text-neon-pink">.</span>
         </a>
         
         <nav class="hidden md:flex items-center gap-1 rounded-full p-1 border bg-white/5 border-white/5">
             {navLinks.map(({ href, label }) => {
                 const isActive = href === '/' ? pathname === '/' : (pathname.startsWith(href) && href !== '/#about');
                 return (
                     <a 
                         href={href} 
                         class:list={[
                             "text-xs font-bold px-4 py-1.5 rounded-full transition-all duration-300",
                             isActive ? "bg-white text-black shadow-lg" : "text-gray-400 hover:text-white hover:bg-white/10"
                         ]}
                     >
                         {label}
                     </a>
                 );
             })}
         </nav>
 
         <a href="#contact" class="hidden md:inline-flex items-center justify-center w-10 h-10 rounded-full bg-neon-cyan text-dark-bg hover:bg-white transition-all shadow-[0_0_15px_rgba(5,217,232,0.4)] shrink-0 group">
            <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 group-hover:scale-110 transition-transform" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
            </svg>
        </a>
         
         <!-- Mobile Menu Button -->
         <button class="md:hidden hover:scale-110 transition-transform focus:outline-none text-white hover:text-neon-pink">
             <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-8 h-8">
             <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
             </svg>
         </button>
     </div>
 </header>

<script>
    class HeaderParticles {
        canvas: HTMLCanvasElement | null;
        header: HTMLElement | null;
        ctx: CanvasRenderingContext2D | null;
        particles: any[];
        mouseX: number;
        mouseY: number;
        isLight: boolean;

        constructor() {
            this.canvas = document.getElementById('header-canvas') as HTMLCanvasElement;
            this.header = document.getElementById('main-header');
            this.ctx = null;
            this.particles = [];
            this.mouseX = -1000;
            this.mouseY = -1000;
            this.isLight = false;
            
            if (!this.canvas || !this.header) return;

            this.ctx = this.canvas.getContext('2d');
            this.isLight = this.header.dataset.theme === 'light';
            
            this.init();
        }

        init() {
            this.resize();
            this.createParticles();
            this.addEventListeners();
            this.animate();
        }

        resize() {
            if (!this.canvas || !this.header) return;
            // Set canvas size to match header actual projected size
            const rect = this.header.getBoundingClientRect();
            this.canvas.width = rect.width;
            this.canvas.height = rect.height;
        }

        createParticles() {
            if (!this.canvas) return;
            const particleCount = 40; // Dense enough but performant
            for (let i = 0; i < particleCount; i++) {
                this.particles.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    size: Math.random() * 2 + 0.5,
                    color: this.isLight 
                        ? (Math.random() > 0.5 ? '#9333ea' : '#000000') // Purple/Black for light
                        : (Math.random() > 0.5 ? '#05d9e8' : '#ff2a6d')  // Cyan/Pink for dark
                });
            }
        }

        addEventListeners() {
            window.addEventListener('resize', () => {
                this.resize();
                this.particles = [];
                this.createParticles();
            });
            
            // Track mouse relative to the header
            document.addEventListener('mousemove', (e) => {
                if (!this.header) return;
                const rect = this.header.getBoundingClientRect();
                if (
                    e.clientX >= rect.left && 
                    e.clientX <= rect.right && 
                    e.clientY >= rect.top && 
                    e.clientY <= rect.bottom
                ) {
                    this.mouseX = e.clientX - rect.left;
                    this.mouseY = e.clientY - rect.top;
                } else {
                    this.mouseX = -1000;
                    this.mouseY = -1000;
                }
            });
        }

        animate() {
            if (!this.ctx || !this.canvas) return;
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            this.particles.forEach(p => {
                if (!this.canvas) return;
                // Update position
                p.x += p.vx;
                p.y += p.vy;

                // Bounce off edges
                if (p.x < 0 || p.x > this.canvas.width) p.vx *= -1;
                if (p.y < 0 || p.y > this.canvas.height) p.vy *= -1;

                // Mouse interaction (Repulsion)
                const dx = this.mouseX - p.x;
                const dy = this.mouseY - p.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDist = 80;

                if (distance < maxDist) {
                    const forceDirectionX = dx / distance;
                    const forceDirectionY = dy / distance;
                    const force = (maxDist - distance) / maxDist;
                    
                    // Push away nicely
                    const repulsionStrength = 2; 
                    p.vx -= forceDirectionX * force * repulsionStrength;
                    p.vy -= forceDirectionY * force * repulsionStrength;
                }
                
                // Friction to stabilize speed
                // p.vx *= 0.99;
                // p.vy *= 0.99;
                
                // Limit max speed
                const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                const maxSpeed = 1.5;
                if (speed > maxSpeed) {
                    p.vx = (p.vx / speed) * maxSpeed;
                    p.vy = (p.vy / speed) * maxSpeed;
                }

                if (!this.ctx) return;
                // Draw
                this.ctx.globalAlpha = 0.6;
                this.ctx.fillStyle = p.color;
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                this.ctx.fill();
            });

            // Connect nearby circles
            this.particles.forEach((p1, i) => {
                this.particles.slice(i + 1).forEach(p2 => {
                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 50 && this.ctx) {
                        this.ctx.beginPath();
                        this.ctx.strokeStyle = this.isLight ? 'rgba(0,0,0,0.1)' : 'rgba(255,255,255,0.1)';
                        this.ctx.lineWidth = 0.5;
                        this.ctx.moveTo(p1.x, p1.y);
                        this.ctx.lineTo(p2.x, p2.y);
                        this.ctx.stroke();
                    }
                });
            });

            requestAnimationFrame(() => this.animate());
        }
    }

    // Initialize on load
    document.addEventListener('astro:page-load', () => {
         new HeaderParticles();
    });
    // Fallback for non-SPA
    new HeaderParticles();
</script>
